-- Sistema Social Completo - Fase 2: Chat Privado Real

-- ===============================
-- 1. CONVERSAS PRIVADAS
-- ===============================

create table private_conversations (
  id bigint generated by default as identity primary key,
  user_1_id uuid references auth.users not null,
  user_2_id uuid references auth.users not null,
  last_message_at timestamp with time zone default timezone('utc'::text, now()) not null,
  last_message_preview text,
  unread_count_user_1 int default 0,
  unread_count_user_2 int default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_1_id, user_2_id),
  check (user_1_id < user_2_id) -- Garantir ordem consistente
);

-- ===============================
-- 2. MENSAGENS PRIVADAS
-- ===============================

create table private_messages (
  id bigint generated by default as identity primary key,
  conversation_id bigint references private_conversations(id) on delete cascade not null,
  sender_id uuid references auth.users not null,
  content text not null,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Índice para performance
create index private_messages_conversation_id_idx on private_messages(conversation_id);
create index private_messages_created_at_idx on private_messages(created_at desc);

-- ===============================
-- 3. NOTIFICAÇÕES
-- ===============================

create table notifications (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  type text not null check (type in ('friend_request', 'friend_accepted', 'message', 'mention', 'like', 'comment', 'community_invite', 'moderation')),
  title text not null,
  content text,
  reference_type text,
  reference_id bigint,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index notifications_user_id_idx on notifications(user_id, is_read);

-- ===============================
-- 4. RLS POLICIES
-- ===============================

-- Private Conversations
alter table private_conversations enable row level security;

create policy "Users can view their own conversations" on private_conversations
  for select using (auth.uid() = user_1_id or auth.uid() = user_2_id);

create policy "Users can create conversations" on private_conversations
  for insert with check (auth.uid() = user_1_id or auth.uid() = user_2_id);

create policy "Users can update their conversations" on private_conversations
  for update using (auth.uid() = user_1_id or auth.uid() = user_2_id);

-- Private Messages
alter table private_messages enable row level security;

create policy "Users can view messages in their conversations" on private_messages
  for select using (
    exists(
      select 1 from private_conversations
      where id = conversation_id
      and (user_1_id = auth.uid() or user_2_id = auth.uid())
    )
  );

create policy "Users can send messages in their conversations" on private_messages
  for insert with check (
    sender_id = auth.uid() and
    exists(
      select 1 from private_conversations
      where id = conversation_id
      and (user_1_id = auth.uid() or user_2_id = auth.uid())
    )
  );

create policy "Users can update their own messages" on private_messages
  for update using (sender_id = auth.uid());

-- Notifications
alter table notifications enable row level security;

create policy "Users can view their own notifications" on notifications
  for select using (auth.uid() = user_id);

create policy "System can create notifications" on notifications
  for insert with check (true);

create policy "Users can update their notifications" on notifications
  for update using (auth.uid() = user_id);

-- ===============================
-- 5. FUNCTIONS
-- ===============================

-- Criar ou buscar conversa entre dois usuários
create or replace function get_or_create_conversation(
  p_user_1_id uuid,
  p_user_2_id uuid
)
returns bigint
language plpgsql
security definer
as $$
declare
  v_conversation_id bigint;
  v_min_id uuid;
  v_max_id uuid;
begin
  -- Garantir ordem consistente
  v_min_id := least(p_user_1_id, p_user_2_id);
  v_max_id := greatest(p_user_1_id, p_user_2_id);

  -- Buscar conversa existente
  select id into v_conversation_id
  from private_conversations
  where user_1_id = v_min_id and user_2_id = v_max_id;

  if not found then
    -- Criar nova conversa
    insert into private_conversations (user_1_id, user_2_id)
    values (v_min_id, v_max_id)
    returning id into v_conversation_id;
  end if;

  return v_conversation_id;
end;
$$;

-- Enviar mensagem
create or replace function send_message(
  p_sender_id uuid,
  p_receiver_id uuid,
  p_content text
)
returns bigint
language plpgsql
security definer
as $$
declare
  v_conversation_id bigint;
  v_message_id bigint;
  v_is_user_1 boolean;
begin
  -- Obter ou criar conversa
  v_conversation_id := get_or_create_conversation(p_sender_id, p_receiver_id);

  -- Inserir mensagem
  insert into private_messages (conversation_id, sender_id, content)
  values (v_conversation_id, p_sender_id, p_content)
  returning id into v_message_id;

  -- Determinar se sender é user_1
  select (user_1_id = p_sender_id) into v_is_user_1
  from private_conversations
  where id = v_conversation_id;

  -- Atualizar conversa
  update private_conversations
  set last_message_at = now(),
      last_message_preview = left(p_content, 100),
      unread_count_user_1 = case when v_is_user_1 then unread_count_user_1 else unread_count_user_1 + 1 end,
      unread_count_user_2 = case when v_is_user_1 then unread_count_user_2 + 1 else unread_count_user_2 end
  where id = v_conversation_id;

  -- Criar notificação
  insert into notifications (user_id, type, title, content, reference_type, reference_id)
  values (
    p_receiver_id,
    'message',
    'Nova mensagem',
    left(p_content, 50),
    'conversation',
    v_conversation_id
  );

  return v_message_id;
end;
$$;

-- Marcar mensagens como lidas
create or replace function mark_messages_as_read(
  p_conversation_id bigint,
  p_user_id uuid
)
returns void
language plpgsql
security definer
as $$
declare
  v_is_user_1 boolean;
begin
  -- Marcar mensagens não lidas como lidas
  update private_messages
  set is_read = true
  where conversation_id = p_conversation_id
  and sender_id != p_user_id
  and is_read = false;

  -- Determinar se é user_1
  select (user_1_id = p_user_id) into v_is_user_1
  from private_conversations
  where id = p_conversation_id;

  if not found then
    return;
  end if;

  -- Zerar contador de não lidas
  update private_conversations
  set unread_count_user_1 = case when v_is_user_1 then 0 else unread_count_user_1 end,
      unread_count_user_2 = case when v_is_user_1 then unread_count_user_2 else 0 end
  where id = p_conversation_id;
end;
$$;

-- Buscar conversas do usuário
create or replace function get_user_conversations(p_user_id uuid)
returns table(
  conversation_id bigint,
  other_user_id uuid,
  other_user_name text,
  other_user_avatar text,
  last_message_at timestamp with time zone,
  last_message_preview text,
  unread_count int
)
language sql
security definer
as $$
  select
    c.id as conversation_id,
    case when c.user_1_id = p_user_id then c.user_2_id else c.user_1_id end as other_user_id,
    p.full_name as other_user_name,
    p.avatar_url as other_user_avatar,
    c.last_message_at,
    c.last_message_preview,
    case when c.user_1_id = p_user_id then c.unread_count_user_1 else c.unread_count_user_2 end as unread_count
  from private_conversations c
  join profiles p on (
    case when c.user_1_id = p_user_id then c.user_2_id else c.user_1_id end = p.id
  )
  where c.user_1_id = p_user_id or c.user_2_id = p_user_id
  order by c.last_message_at desc;
$$;

-- ===============================
-- 6. TRIGGERS
-- ===============================

-- Trigger para criar notificação de amizade aceita
create or replace function notify_friend_accepted()
returns trigger
language plpgsql
security definer
as $$
begin
  if NEW.status = 'accepted' and OLD.status = 'pending' then
    insert into notifications (user_id, type, title, reference_type, reference_id)
    values (
      NEW.sender_id,
      'friend_accepted',
      'Solicitação aceita',
      'user',
      NEW.receiver_id::bigint
    );
  end if;
  return NEW;
end;
$$;

create trigger friend_request_accepted_trigger
after update on friend_requests
for each row
execute function notify_friend_accepted();
