-- Sistema Social Completo - Fase 4: Moderação Avançada e Fase 5: Refinamentos

-- ===============================
-- FASE 4: MODERAÇÃO AVANÇADA
-- ===============================

-- Lista de palavras ofensivas (filtro automático)
create table offensive_words (
  id bigint generated by default as identity primary key,
  word text not null unique,
  severity text default 'medium' check (severity in ('low', 'medium', 'high', 'critical')),
  auto_flag boolean default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Analytics de moderação
create table moderation_stats (
  id bigint generated by default as identity primary key,
  date date not null default current_date,
  total_flags int default 0,
  auto_flags int default 0,
  manual_flags int default 0,
  resolved_flags int default 0,
  strikes_applied int default 0,
  bans_applied int default 0,
  average_resolution_time_minutes int default 0,
  unique(date)
);

-- Logs de ações de moderação detalhados
create table moderation_logs (
  id bigint generated by default as identity primary key,
  moderator_id uuid references auth.users,
  action_type text not null check (action_type in ('flag_review', 'strike_apply', 'ban_apply', 'content_remove', 'user_warn')),
  target_type text not null check (target_type in ('user', 'post', 'comment', 'community', 'message')),
  target_id bigint not null,
  details jsonb,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- ===============================
-- FASE 5: REFINAMENTOS
-- ===============================

-- Configurações de privacidade do usuário (já adicionado em profiles, mas melhorando)
alter table profiles add column if not exists show_online_status boolean default true;
alter table profiles add column if not exists allow_friend_requests boolean default true;
alter table profiles add column if not exists searchable boolean default true;

-- Atividades recentes do usuário
create table user_activity_log (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  activity_type text not null check (activity_type in ('login', 'post', 'comment', 'like', 'join_community', 'message_sent', 'achievement_unlocked')),
  reference_type text,
  reference_id bigint,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index user_activity_log_user_id_idx on user_activity_log(user_id, created_at desc);

-- Saved posts (posts salvos para ler depois)
create table saved_posts (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  post_id bigint references posts(id) on delete cascade,
  community_post_id bigint references community_posts(id) on delete cascade,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  check ((post_id is not null and community_post_id is null) or (post_id is null and community_post_id is not null))
);

-- Bloqueio de usuários
create table user_blocks (
  id bigint generated by default as identity primary key,
  blocker_id uuid references auth.users not null,
  blocked_id uuid references auth.users not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(blocker_id, blocked_id),
  check (blocker_id != blocked_id)
);

-- Analytics gerais
create table app_analytics (
  id bigint generated by default as identity primary key,
  date date not null default current_date,
  daily_active_users int default 0,
  new_users int default 0,
  total_posts int default 0,
  total_comments int default 0,
  total_messages int default 0,
  total_communities_created int default 0,
  average_session_minutes int default 0,
  unique(date)
);

-- ===============================
-- RLS POLICIES
-- ===============================

-- Offensive Words (apenas moderadores)
alter table offensive_words enable row level security;

create policy "Moderators can manage offensive words" on offensive_words
  for all using (
    exists(
      select 1 from profiles where id = auth.uid() and role in ('moderator', 'admin')
    )
  );

-- Moderation Stats (apenas moderadores)
alter table moderation_stats enable row level security;

create policy "Moderators can view moderation stats" on moderation_stats
  for select using (
    exists(
      select 1 from profiles where id = auth.uid() and role in ('moderator', 'admin')
    )
  );

-- Moderation Logs (apenas moderadores)
alter table moderation_logs enable row level security;

create policy "Moderators can view moderation logs" on moderation_logs
  for select using (
    exists(
      select 1 from profiles where id = auth.uid() and role in ('moderator', 'admin')
    )
  );

create policy "Moderators can create logs" on moderation_logs
  for insert with check (
    exists(
      select 1 from profiles where id = auth.uid() and role in ('moderator', 'admin')
    )
  );

-- User Activity Log
alter table user_activity_log enable row level security;

create policy "Users can view their own activity" on user_activity_log
  for select using (auth.uid() = user_id);

create policy "System can log activity" on user_activity_log
  for insert with check (true);

-- Saved Posts
alter table saved_posts enable row level security;

create policy "Users can manage their saved posts" on saved_posts
  for all using (auth.uid() = user_id);

-- User Blocks
alter table user_blocks enable row level security;

create policy "Users can manage their blocks" on user_blocks
  for all using (auth.uid() = blocker_id);

create policy "Users can view if they're blocked" on user_blocks
  for select using (auth.uid() = blocked_id);

-- App Analytics (apenas admin)
alter table app_analytics enable row level security;

create policy "Admins can view analytics" on app_analytics
  for select using (
    exists(
      select 1 from profiles where id = auth.uid() and role = 'admin'
    )
  );

-- ===============================
-- FUNCTIONS
-- ===============================

-- Verificar conteúdo ofensivo automaticamente
create or replace function check_offensive_content(p_content text)
returns table(is_offensive boolean, matched_words text[], severity text)
language plpgsql
security definer
as $$
declare
  v_matched_words text[] := array[]::text[];
  v_max_severity text := 'low';
  v_word record;
begin
  -- Buscar palavras ofensivas no conteúdo
  for v_word in 
    select word, severity from offensive_words where auto_flag = true
  loop
    if lower(p_content) ~ lower(v_word.word) then
      v_matched_words := array_append(v_matched_words, v_word.word);
      
      -- Atualizar severidade máxima
      if v_word.severity = 'critical' or v_max_severity = 'critical' then
        v_max_severity := 'critical';
      elsif v_word.severity = 'high' and v_max_severity != 'critical' then
        v_max_severity := 'high';
      elsif v_word.severity = 'medium' and v_max_severity not in ('critical', 'high') then
        v_max_severity := 'medium';
      end if;
    end if;
  end loop;

  return query select 
    array_length(v_matched_words, 1) > 0 as is_offensive,
    v_matched_words,
    v_max_severity;
end;
$$;

-- Buscar denúncias pendentes (para painel de moderação)
create or replace function get_pending_flags(p_limit int default 50)
returns table(
  flag_id bigint,
  content_type text,
  content_id bigint,
  reporter_name text,
  flag_type text,
  description text,
  created_at timestamp with time zone,
  content_preview text
)
language sql
security definer
as $$
  select
    cf.id as flag_id,
    cf.content_type,
    cf.content_id,
    p.full_name as reporter_name,
    cf.flag_type,
    cf.description,
    cf.created_at,
    case
      when cf.content_type = 'post' then (select left(content, 100) from posts where id = cf.content_id)
      when cf.content_type = 'comment' then (select left(content, 100) from post_comments where id = cf.content_id)
      else 'N/A'
    end as content_preview
  from content_flags cf
  join profiles p on cf.reporter_id = p.id
  where cf.status = 'pending'
  order by cf.created_at asc
  limit p_limit;
$$;

-- Resolver denúncia
create or replace function resolve_flag(
  p_flag_id bigint,
  p_action text,
  p_notes text default null
)
returns void
language plpgsql
security definer
as $$
declare
  v_flag record;
begin
  -- Verificar se é moderador
  if not exists(
    select 1 from profiles where id = auth.uid() and role in ('moderator', 'admin')
  ) then
    raise exception 'Not authorized';
  end if;

  -- Buscar flag
  select * into v_flag from content_flags where id = p_flag_id;

  if not found then
    raise exception 'Flag not found';
  end if;

  -- Atualizar flag
  update content_flags
  set status = 'resolved',
      moderator_id = auth.uid(),
      moderator_notes = p_notes,
      resolved_at = now()
  where id = p_flag_id;

  -- Registrar log
  insert into moderation_logs (moderator_id, action_type, target_type, target_id, details)
  values (
    auth.uid(),
    'flag_review',
    v_flag.content_type,
    v_flag.content_id,
    jsonb_build_object('action', p_action, 'flag_type', v_flag.flag_type)
  );

  -- Se ação for strike, aplicar
  if p_action = 'strike' then
    perform apply_strike(v_flag.reporter_id, v_flag.flag_type || ': ' || coalesce(p_notes, ''), auth.uid());
  end if;
end;
$$;

-- Log de atividade do usuário
create or replace function log_user_activity(
  p_activity_type text,
  p_reference_type text default null,
  p_reference_id bigint default null
)
returns void
language plpgsql
security definer
as $$
begin
  insert into user_activity_log (user_id, activity_type, reference_type, reference_id)
  values (auth.uid(), p_activity_type, p_reference_type, p_reference_id);
end;
$$;

-- Analytics: usuários ativos hoje
create or replace function get_daily_active_users()
returns int
language sql
security definer
as $$
  select count(distinct user_id)
  from user_activity_log
  where created_at >= current_date;
$$;

-- ===============================
-- TRIGGERS
-- ===============================

-- Auto-flag conteúdo ofensivo em posts
create or replace function auto_flag_offensive_posts()
returns trigger
language plpgsql
as $$
declare
  v_check record;
begin
  -- Verificar conteúdo
  select * into v_check from check_offensive_content(NEW.content);

  if v_check.is_offensive then
    -- Criar flag automática
    insert into content_flags (content_type, content_id, reporter_id, flag_type, description, status)
    values (
      'post',
      NEW.id,
      NEW.user_id, -- Sistema
      'offensive',
      'Auto-flagged: ' || array_to_string(v_check.matched_words, ', '),
      'pending'
    );

    -- Se severidade crítica, aplicar strike imediatamente
    if v_check.severity = 'critical' then
      perform apply_strike(NEW.user_id, 'Conteúdo extremamente ofensivo detectado automaticamente', null);
    end if;
  end if;

  return NEW;
end;
$$;

create trigger auto_flag_posts_trigger
after insert on posts
for each row
execute function auto_flag_offensive_posts();

-- Inserir palavras ofensivas padrão
insert into offensive_words (word, severity, auto_flag) values
  ('racis', 'critical', true),
  ('sexis', 'critical', true),
  ('homofob', 'critical', true),
  ('transfob', 'critical', true),
  ('nazi', 'critical', true),
  ('hitler', 'high', true),
  ('terroris', 'critical', true),
  ('suicid', 'high', false), -- não auto-flag, pode ser pedido de ajuda
  ('idiota', 'low', false),
  ('burro', 'low', false)
on conflict (word) do nothing;
